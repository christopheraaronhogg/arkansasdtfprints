## Proposed Solution

### 1. Implement a Queue-Based Email System

Create a job queue system to handle emails asynchronously:

```python
# In a new file: email_queue.py
import json
import threading
import time
import queue
import logging
from flask import current_app
from sendgrid import SendGridAPIClient
from sendgrid.helpers.mail import Mail as SGMail

logger = logging.getLogger(__name__)

# Global queue for email jobs
email_queue = queue.Queue()
# Flag to control the worker thread
_worker_running = False

def enqueue_email(email_type, data):
    """Add an email job to the queue"""
    email_queue.put({
        'type': email_type,
        'data': data,
        'attempts': 0,
        'created_at': time.time()
    })
    logger.info(f"Email job of type {email_type} enqueued")
    start_worker_if_needed()

def start_worker_if_needed():
    """Start the worker thread if it's not already running"""
    global _worker_running
    
    if not _worker_running:
        _worker_running = True
        thread = threading.Thread(target=process_email_queue)
        thread.daemon = True
        thread.start()
        logger.info("Started email worker thread")

def process_email_queue():
    """Worker function to process the email queue"""
    global _worker_running
    
    logger.info("Email queue worker started")
    try:
        while not email_queue.empty():
            try:
                job = email_queue.get(block=False)
                process_email_job(job)
                email_queue.task_done()
            except queue.Empty:
                break
            except Exception as e:
                logger.error(f"Error processing email job: {str(e)}")
    finally:
        _worker_running = False
        logger.info("Email queue worker stopped")

def process_email_job(job):
    """Process a single email job"""
    from app import app  # Import here to avoid circular imports
    
    email_type = job['type']
    data = job['data']
    attempts = job['attempts']
    
    # Max retry limit
    MAX_ATTEMPTS = 3
    
    if attempts >= MAX_ATTEMPTS:
        logger.error(f"Email job of type {email_type} failed after {attempts} attempts: {data}")
        return
    
    logger.info(f"Processing email job of type {email_type}, attempt {attempts+1}")
    
    try:
        with app.app_context():
            if email_type == 'customer_order_confirmation':
                send_customer_email(data)
            elif email_type == 'production_order_notification':
                send_production_email(data)
            else:
                logger.error(f"Unknown email type: {email_type}")
    except Exception as e:
        logger.error(f"Failed to send {email_type} email: {str(e)}")
        
        # Increment attempt count and re-queue if under max attempts
        job['attempts'] += 1
        if job['attempts'] < MAX_ATTEMPTS:
            email_queue.put(job)
            logger.info(f"Requeued {email_type} email for retry, attempt {job['attempts']}")

def send_customer_email(data):
    """Send customer order confirmation email"""
    from flask import render_template
    from app import Order
    
    order_id = data.get('order_id')
    order = Order.query.get(order_id)
    
    if not order:
        logger.error(f"Cannot send customer email: Order {order_id} not found")
        return
    
    customer_email = SGMail(
        from_email=('info@appareldecorating.net', 'DTF Printing'),
        to_emails=order.email,
        subject=f'DTF Printing Order Confirmation - {order.order_number}',
        html_content=render_template('emails/customer_order_confirmation.html', order=order)
    )
    
    send_via_sendgrid(customer_email, f"customer email for order {order.order_number}")

def send_production_email(data):
    """Send production team notification email"""
    from flask import render_template
    from app import Order
    from config import Config
    
    order_id = data.get('order_id')
    order = Order.query.get(order_id)
    
    if not order:
        logger.error(f"Cannot send production email: Order {order_id} not found")
        return
    
    production_email = SGMail(
        from_email=('info@appareldecorating.net', 'DTF Printing'),
        to_emails=Config.PRODUCTION_TEAM_EMAIL,
        subject=f'New DTF Printing Order - {order.order_number}',
        html_content=render_template('emails/production_order_notification.html', order=order)
    )
    
    send_via_sendgrid(production_email, f"production team email for order {order.order_number}")

def send_via_sendgrid(email, description):
    """Send an email via SendGrid API with proper error handling"""
    from config import Config
    
    api_key = Config.SENDGRID_API_KEY
    if not api_key:
        logger.error(f"Cannot send {description}: SendGrid API key not configured")
        raise ValueError("SendGrid API key not configured")
    
    try:
        sg = SendGridAPIClient(api_key)
        response = sg.send(email)
        
        if response.status_code not in [200, 201, 202]:
            logger.error(f"Failed to send {description}. Status code: {response.status_code}")
            logger.error(f"Response body: {response.body.decode('utf-8') if hasattr(response, 'body') else 'No body'}")
            raise Exception(f"SendGrid API returned status {response.status_code}")
        
        logger.info(f"Successfully sent {description}")
        
    except Exception as e:
        logger.error(f"SendGrid API error for {description}: {str(e)}")
        if hasattr(e, 'body'):
            try:
                error_body = e.body.decode('utf-8')
                logger.error(f"SendGrid API error details: {error_body}")
            except:
                logger.error("Could not decode error body")
        raise
```

### 2. Modify the App to Use the Queue System

Update the current email sending process to use the new queue system:

```python
# In app.py, replace the send_order_emails function with:

def send_order_emails(order):
    """Enqueue order confirmation emails to customer and production team"""
    try:
        from email_queue import enqueue_email
        
        # Log that we're enqueueing emails
        logger.info(f"Enqueueing emails for order {order.order_number}")
        
        # Enqueue customer email
        enqueue_email('customer_order_confirmation', {'order_id': order.id})
        
        # Enqueue production team email
        enqueue_email('production_order_notification', {'order_id': order.id})
        
        return True
    except Exception as e:
        logger.error(f"Error enqueueing emails: {str(e)}")
        return False
```

### 3. Add Email Job Status Tracking (Optional Enhancement)

For better observability and to allow for manual retries, implement email job status tracking:

```python
# Add to models.py

class EmailJob(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    email_type = db.Column(db.String(50), nullable=False)
    order_id = db.Column(db.Integer, db.ForeignKey('order.id'), nullable=False)
    recipient = db.Column(db.String(255), nullable=False)
    subject = db.Column(db.String(255), nullable=False)
    status = db.Column(db.String(20), nullable=False, default='pending')
    attempts = db.Column(db.Integer, default=0)
    error_message = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    order = db.relationship('Order', backref=db.backref('email_jobs', lazy=True))
```

### 4. Add Manual Retry Capability in Admin Interface

Add an admin interface to view email status and manually retry failed emails.

### 5. Add Monitoring and Alerts

Implement monitoring to alert when email sending fails consistently:

```python
# Add to email_queue.py

def check_for_stuck_emails():
    """Check for emails that have been stuck in the queue for too long"""
    from app import EmailJob
    
    # Find jobs that are still pending and were created more than 15 minutes ago
    cutoff_time = datetime.utcnow() - timedelta(minutes=15)
    stuck_jobs = EmailJob.query.filter(
        EmailJob.status == 'pending',
        EmailJob.created_at < cutoff_time
    ).all()
    
    if stuck_jobs:
        logger.warning(f"Found {len(stuck_jobs)} stuck email jobs. Alerting...")
        # Implementation of alert (email, Slack, etc.)
```

## Deployment Considerations for Replit

When deploying these changes to Replit, consider these additional steps:

1. **Ensure Persistent Environment Variables**: Make sure the SendGrid API key is properly set in Replit's environment variables or secrets management.

2. **Keep-Alive Implementation**: To prevent the Replit container from going to sleep, implement a keep-alive mechanism using UptimeRobot or a similar service.

3. **Monitor Memory Usage**: Ensure the application doesn't exceed Replit's memory limits, especially when processing large batches of emails.

4. **Consider Upgrading Replit Plan**: If available, consider upgrading to a paid Replit plan that offers better reliability and uptime guarantees.

5. **Implement Health Checks**: Add a health check endpoint to verify that the email service is working correctly.

## Conclusion

The intermittent email sending issues are likely caused by the synchronous, non-retrying nature of the current implementation combined with the constraints of the Replit hosting environment. The proposed queue-based system will add resilience by:

1. Moving email sending out of the main request path
2. Adding automatic retries for failed emails
3. Providing better observability and troubleshooting capabilities
4. Handling Replit environment constraints more gracefully

This solution should significantly improve the reliability of the email sending process while maintaining the existing email templates and SendGrid integration. 